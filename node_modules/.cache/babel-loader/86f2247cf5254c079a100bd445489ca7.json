{"ast":null,"code":"function __$styleInject(css) {\n  if (!css) return;\n  if (typeof window == 'undefined') return;\n  var style = document.createElement('style');\n  style.setAttribute('media', 'screen');\n  style.innerHTML = css;\n  document.head.appendChild(style);\n  return css;\n}\n\nimport _asyncToGenerator from '@babel/runtime/helpers/esm/asyncToGenerator';\nimport _extends from '@babel/runtime/helpers/esm/extends';\nimport _objectWithoutPropertiesLoose from '@babel/runtime/helpers/esm/objectWithoutPropertiesLoose';\nimport _regeneratorRuntime from '@babel/runtime/regenerator';\nimport React, { forwardRef, useRef, useState, useMemo, useCallback, memo, useEffect } from 'react';\nimport Cropper from 'react-easy-crop';\nimport LocaleReceiver from 'antd/es/locale-provider/LocaleReceiver';\nimport AntModal from 'antd/es/modal';\nimport AntSlider from 'antd/es/slider';\n\n__$styleInject(\".img-crop-modal .img-crop-container {\\n  position: relative;\\n  width: 100%;\\n  height: 40vh;\\n}\\n.img-crop-modal .img-crop-control {\\n  display: flex;\\n  align-items: center;\\n  width: 60%;\\n  margin-left: auto;\\n  margin-right: auto;\\n}\\n.img-crop-modal .img-crop-control:first-of-type {\\n  margin-top: 16px;\\n}\\n.img-crop-modal .img-crop-control:last-of-type {\\n  margin-bottom: -8px;\\n}\\n.img-crop-modal .img-crop-control button {\\n  display: flex;\\n  justify-content: center;\\n  align-items: center;\\n  width: 34px;\\n  height: 34px;\\n  padding: 0;\\n  font-style: normal;\\n  background: transparent;\\n  border: 0;\\n  outline: 0;\\n  cursor: pointer;\\n}\\n.img-crop-modal .img-crop-control button[disabled] {\\n  cursor: default;\\n}\\n.img-crop-modal .img-crop-control button + div:only-of-type {\\n  flex: 1;\\n  margin: 0 8px;\\n}\\n.img-crop-modal .img-crop-control-zoom button {\\n  font-size: 18px;\\n}\\n.img-crop-modal .img-crop-control-rotate button {\\n  font-size: 16px;\\n}\\n.img-crop-modal .img-crop-control-rotate button:first-of-type {\\n  transform: rotate(-20deg);\\n}\\n.img-crop-modal .img-crop-control-rotate button:last-of-type {\\n  transform: rotate(20deg);\\n}\\n\");\n\nvar _excluded = [\"beforeUpload\", \"accept\"];\nvar cls = 'img-crop';\nvar INIT_ZOOM = 1;\nvar ZOOM_STEP = 0.1;\nvar INIT_ROTATE = 0;\nvar ROTATE_STEP = 1;\nvar MIN_ROTATE = -180;\nvar MAX_ROTATE = 180;\nvar EasyCrop = /*#__PURE__*/forwardRef(function (props, ref) {\n  var image = props.image,\n      aspect = props.aspect,\n      shape = props.shape,\n      grid = props.grid,\n      zoom = props.zoom,\n      rotate = props.rotate,\n      minZoom = props.minZoom,\n      maxZoom = props.maxZoom,\n      rotateValRef = props.rotateValRef,\n      setZoomValRef = props.setZoomValRef,\n      setRotateValRef = props.setRotateValRef,\n      cropPixelsRef = props.cropPixelsRef,\n      cropperProps = props.cropperProps;\n\n  var _useState = useState({\n    x: 0,\n    y: 0\n  }),\n      crop = _useState[0],\n      onCropChange = _useState[1];\n\n  var _useState2 = useState({\n    width: 0,\n    height: 0\n  }),\n      cropSize = _useState2[0],\n      setCropSize = _useState2[1];\n\n  var onCropComplete = useCallback(function (croppedArea, croppedAreaPixels) {\n    cropPixelsRef.current = croppedAreaPixels;\n  }, [cropPixelsRef]);\n  var onMediaLoaded = useCallback(function (mediaSize) {\n    var width = mediaSize.width,\n        height = mediaSize.height;\n    var ratioWidth = height * aspect;\n\n    if (width > ratioWidth) {\n      setCropSize({\n        width: ratioWidth,\n        height: height\n      });\n    } else {\n      setCropSize({\n        width: width,\n        height: width / aspect\n      });\n    }\n  }, [aspect]);\n\n  var _useState3 = useState(INIT_ZOOM),\n      zoomVal = _useState3[0],\n      setZoomVal = _useState3[1];\n\n  var _useState4 = useState(INIT_ROTATE),\n      rotateVal = _useState4[0],\n      setRotateVal = _useState4[1];\n\n  rotateValRef.current = rotateVal;\n  useEffect(function () {\n    setZoomValRef.current = setZoomVal;\n    setRotateValRef.current = setRotateVal;\n  }, [setRotateValRef, setZoomValRef]);\n  return /*#__PURE__*/React.createElement(React.Fragment, null, /*#__PURE__*/React.createElement(Cropper, Object.assign({}, cropperProps, {\n    ref: ref,\n    image: image,\n    crop: crop,\n    cropSize: cropSize,\n    onCropChange: onCropChange,\n    aspect: aspect,\n    cropShape: shape,\n    showGrid: grid,\n    zoomWithScroll: zoom,\n    zoom: zoomVal,\n    rotation: rotateVal,\n    onZoomChange: setZoomVal,\n    onRotationChange: setRotateVal,\n    minZoom: minZoom,\n    maxZoom: maxZoom,\n    onCropComplete: onCropComplete,\n    onMediaLoaded: onMediaLoaded,\n    classes: {\n      containerClassName: cls + \"-container\",\n      mediaClassName: cls + \"-media\"\n    }\n  })), zoom && /*#__PURE__*/React.createElement(\"section\", {\n    className: cls + \"-control \" + cls + \"-control-zoom\"\n  }, /*#__PURE__*/React.createElement(\"button\", {\n    onClick: function onClick() {\n      return setZoomVal(zoomVal - ZOOM_STEP);\n    },\n    disabled: zoomVal - ZOOM_STEP < minZoom\n  }, \"\\uFF0D\"), /*#__PURE__*/React.createElement(AntSlider, {\n    min: minZoom,\n    max: maxZoom,\n    step: ZOOM_STEP,\n    value: zoomVal,\n    onChange: setZoomVal\n  }), /*#__PURE__*/React.createElement(\"button\", {\n    onClick: function onClick() {\n      return setZoomVal(zoomVal + ZOOM_STEP);\n    },\n    disabled: zoomVal + ZOOM_STEP > maxZoom\n  }, \"\\uFF0B\")), rotate && /*#__PURE__*/React.createElement(\"section\", {\n    className: cls + \"-control \" + cls + \"-control-rotate\"\n  }, /*#__PURE__*/React.createElement(\"button\", {\n    onClick: function onClick() {\n      return setRotateVal(rotateVal - ROTATE_STEP);\n    },\n    disabled: rotateVal === MIN_ROTATE\n  }, \"\\u21BA\"), /*#__PURE__*/React.createElement(AntSlider, {\n    min: MIN_ROTATE,\n    max: MAX_ROTATE,\n    step: ROTATE_STEP,\n    value: rotateVal,\n    onChange: setRotateVal\n  }), /*#__PURE__*/React.createElement(\"button\", {\n    onClick: function onClick() {\n      return setRotateVal(rotateVal + ROTATE_STEP);\n    },\n    disabled: rotateVal === MAX_ROTATE\n  }, \"\\u21BB\")));\n});\nvar EasyCropMemo = /*#__PURE__*/memo(EasyCrop);\nvar ImgCrop = /*#__PURE__*/forwardRef(function (props, ref) {\n  var _props$aspect = props.aspect,\n      aspect = _props$aspect === void 0 ? 1 : _props$aspect,\n      _props$shape = props.shape,\n      shape = _props$shape === void 0 ? 'rect' : _props$shape,\n      _props$grid = props.grid,\n      grid = _props$grid === void 0 ? false : _props$grid,\n      _props$quality = props.quality,\n      quality = _props$quality === void 0 ? 0.4 : _props$quality,\n      _props$fillColor = props.fillColor,\n      fillColor = _props$fillColor === void 0 ? 'white' : _props$fillColor,\n      _props$zoom = props.zoom,\n      zoom = _props$zoom === void 0 ? true : _props$zoom,\n      _props$rotate = props.rotate,\n      rotate = _props$rotate === void 0 ? false : _props$rotate,\n      _props$minZoom = props.minZoom,\n      minZoom = _props$minZoom === void 0 ? 1 : _props$minZoom,\n      _props$maxZoom = props.maxZoom,\n      maxZoom = _props$maxZoom === void 0 ? 3 : _props$maxZoom,\n      modalTitle = props.modalTitle,\n      modalWidth = props.modalWidth,\n      modalOk = props.modalOk,\n      modalCancel = props.modalCancel,\n      onModalOk = props.onModalOk,\n      onModalCancel = props.onModalCancel,\n      beforeCrop = props.beforeCrop,\n      onUploadFail = props.onUploadFail,\n      cropperProps = props.cropperProps,\n      children = props.children;\n  var cb = useRef({});\n  cb.current.onModalOk = onModalOk;\n  cb.current.onModalCancel = onModalCancel;\n  cb.current.beforeCrop = beforeCrop;\n  cb.current.onUploadFail = onUploadFail;\n  /**\n   * Upload\n   */\n\n  var _useState5 = useState(''),\n      image = _useState5[0],\n      setImage = _useState5[1];\n\n  var fileRef = useRef();\n  var resolveRef = useRef();\n  var rejectRef = useRef();\n  var beforeUploadRef = useRef();\n  var uploadComponent = useMemo(function () {\n    var upload = Array.isArray(children) ? children[0] : children;\n\n    var _upload$props = upload.props,\n        beforeUpload = _upload$props.beforeUpload,\n        accept = _upload$props.accept,\n        restUploadProps = _objectWithoutPropertiesLoose(_upload$props, _excluded);\n\n    beforeUploadRef.current = beforeUpload;\n    return _extends({}, upload, {\n      props: _extends({}, restUploadProps, {\n        accept: accept || 'image/*',\n        beforeUpload: function beforeUpload(file, fileList) {\n          return new Promise( /*#__PURE__*/function () {\n            var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(resolve, reject) {\n              var reader;\n              return _regeneratorRuntime.wrap(function _callee$(_context) {\n                while (1) {\n                  switch (_context.prev = _context.next) {\n                    case 0:\n                      _context.t0 = cb.current.beforeCrop;\n\n                      if (!_context.t0) {\n                        _context.next = 5;\n                        break;\n                      }\n\n                      _context.next = 4;\n                      return cb.current.beforeCrop(file, fileList);\n\n                    case 4:\n                      _context.t0 = !_context.sent;\n\n                    case 5:\n                      if (!_context.t0) {\n                        _context.next = 8;\n                        break;\n                      }\n\n                      reject();\n                      return _context.abrupt(\"return\");\n\n                    case 8:\n                      fileRef.current = file;\n\n                      resolveRef.current = function (newFile) {\n                        cb.current.onModalOk == null ? void 0 : cb.current.onModalOk(newFile);\n                        resolve(newFile);\n                      };\n\n                      rejectRef.current = function (uploadErr) {\n                        cb.current.onUploadFail == null ? void 0 : cb.current.onUploadFail(uploadErr);\n                        reject(uploadErr);\n                      };\n\n                      reader = new FileReader();\n                      reader.addEventListener('load', function () {\n                        return setImage(reader.result);\n                      });\n                      reader.readAsDataURL(file);\n\n                    case 14:\n                    case \"end\":\n                      return _context.stop();\n                  }\n                }\n              }, _callee);\n            }));\n\n            return function (_x, _x2) {\n              return _ref.apply(this, arguments);\n            };\n          }());\n        }\n      })\n    });\n  }, [children]);\n  /**\n   * Crop\n   */\n\n  var rotateValRef = useRef();\n  var setZoomValRef = useRef();\n  var setRotateValRef = useRef();\n  var cropPixelsRef = useRef();\n  /**\n   * Modal\n   */\n\n  var modalProps = useMemo(function () {\n    var obj = {\n      width: modalWidth,\n      okText: modalOk,\n      cancelText: modalCancel\n    };\n    Object.keys(obj).forEach(function (key) {\n      if (!obj[key]) delete obj[key];\n    });\n    return obj;\n  }, [modalCancel, modalOk, modalWidth]);\n\n  var onClose = function onClose() {\n    setImage('');\n    setZoomValRef.current(INIT_ZOOM);\n    setRotateValRef.current(INIT_ROTATE);\n  };\n\n  var onCancel = useCallback(function () {\n    cb.current.onModalCancel == null ? void 0 : cb.current.onModalCancel();\n    onClose();\n  }, []);\n  var onOk = useCallback( /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3() {\n    var canvas, ctx, imgSource, _cropPixelsRef$curren, cropWidth, cropHeight, cropX, cropY, imgWidth, imgHeight, angle, sine, cosine, squareWidth, squareHeight, squareHalfWidth, squareHalfHeight, imgX, imgY, imgData, _fileRef$current, type, name, uid, onBlob;\n\n    return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n      while (1) {\n        switch (_context3.prev = _context3.next) {\n          case 0:\n            onClose();\n            canvas = document.createElement('canvas');\n            ctx = canvas.getContext('2d');\n            imgSource = document.querySelector(\".\" + cls + \"-media\");\n            _cropPixelsRef$curren = cropPixelsRef.current, cropWidth = _cropPixelsRef$curren.width, cropHeight = _cropPixelsRef$curren.height, cropX = _cropPixelsRef$curren.x, cropY = _cropPixelsRef$curren.y;\n\n            if (rotate && rotateValRef.current !== INIT_ROTATE) {\n              imgWidth = imgSource.naturalWidth, imgHeight = imgSource.naturalHeight;\n              angle = rotateValRef.current * (Math.PI / 180); // get container for rotated image\n\n              sine = Math.abs(Math.sin(angle));\n              cosine = Math.abs(Math.cos(angle));\n              squareWidth = imgWidth * cosine + imgHeight * sine;\n              squareHeight = imgHeight * cosine + imgWidth * sine;\n              canvas.width = squareWidth;\n              canvas.height = squareHeight;\n              ctx.fillStyle = fillColor;\n              ctx.fillRect(0, 0, squareWidth, squareHeight); // rotate container\n\n              squareHalfWidth = squareWidth / 2;\n              squareHalfHeight = squareHeight / 2;\n              ctx.translate(squareHalfWidth, squareHalfHeight);\n              ctx.rotate(angle);\n              ctx.translate(-squareHalfWidth, -squareHalfHeight); // draw rotated image\n\n              imgX = (squareWidth - imgWidth) / 2;\n              imgY = (squareHeight - imgHeight) / 2;\n              ctx.drawImage(imgSource, 0, 0, imgWidth, imgHeight, imgX, imgY, imgWidth, imgHeight); // crop rotated image\n\n              imgData = ctx.getImageData(0, 0, squareWidth, squareHeight);\n              canvas.width = cropWidth;\n              canvas.height = cropHeight;\n              ctx.putImageData(imgData, -cropX, -cropY);\n            } else {\n              canvas.width = cropWidth;\n              canvas.height = cropHeight;\n              ctx.fillStyle = fillColor;\n              ctx.fillRect(0, 0, cropWidth, cropHeight);\n              ctx.drawImage(imgSource, cropX, cropY, cropWidth, cropHeight, 0, 0, cropWidth, cropHeight);\n            } // get the new image\n\n\n            _fileRef$current = fileRef.current, type = _fileRef$current.type, name = _fileRef$current.name, uid = _fileRef$current.uid;\n\n            onBlob = /*#__PURE__*/function () {\n              var _ref3 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(blob) {\n                var newFile, res, passedFile, _type;\n\n                return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n                  while (1) {\n                    switch (_context2.prev = _context2.next) {\n                      case 0:\n                        newFile = new File([blob], name, {\n                          type: type\n                        });\n                        newFile.uid = uid;\n\n                        if (!(typeof beforeUploadRef.current !== 'function')) {\n                          _context2.next = 4;\n                          break;\n                        }\n\n                        return _context2.abrupt(\"return\", resolveRef.current(newFile));\n\n                      case 4:\n                        res = beforeUploadRef.current(newFile, [newFile]);\n\n                        if (!(typeof res !== 'boolean' && !res)) {\n                          _context2.next = 8;\n                          break;\n                        }\n\n                        console.error('beforeUpload must return a boolean or Promise');\n                        return _context2.abrupt(\"return\");\n\n                      case 8:\n                        if (!(res === true)) {\n                          _context2.next = 10;\n                          break;\n                        }\n\n                        return _context2.abrupt(\"return\", resolveRef.current(newFile));\n\n                      case 10:\n                        if (!(res === false)) {\n                          _context2.next = 12;\n                          break;\n                        }\n\n                        return _context2.abrupt(\"return\", rejectRef.current('not upload'));\n\n                      case 12:\n                        if (!(res && typeof res.then === 'function')) {\n                          _context2.next = 25;\n                          break;\n                        }\n\n                        _context2.prev = 13;\n                        _context2.next = 16;\n                        return res;\n\n                      case 16:\n                        passedFile = _context2.sent;\n                        _type = Object.prototype.toString.call(passedFile);\n                        if (_type === '[object File]' || _type === '[object Blob]') newFile = passedFile;\n                        resolveRef.current(newFile);\n                        _context2.next = 25;\n                        break;\n\n                      case 22:\n                        _context2.prev = 22;\n                        _context2.t0 = _context2[\"catch\"](13);\n                        rejectRef.current(_context2.t0);\n\n                      case 25:\n                      case \"end\":\n                        return _context2.stop();\n                    }\n                  }\n                }, _callee2, null, [[13, 22]]);\n              }));\n\n              return function onBlob(_x3) {\n                return _ref3.apply(this, arguments);\n              };\n            }();\n\n            canvas.toBlob(onBlob, type, quality);\n\n          case 9:\n          case \"end\":\n            return _context3.stop();\n        }\n      }\n    }, _callee3);\n  })), [fillColor, quality, rotate]);\n\n  var getComponent = function getComponent(titleOfModal) {\n    return /*#__PURE__*/React.createElement(React.Fragment, null, uploadComponent, image && /*#__PURE__*/React.createElement(AntModal, Object.assign({\n      visible: true,\n      wrapClassName: cls + \"-modal\",\n      title: titleOfModal,\n      onOk: onOk,\n      onCancel: onCancel,\n      maskClosable: false,\n      destroyOnClose: true\n    }, modalProps), /*#__PURE__*/React.createElement(EasyCropMemo, {\n      ref: ref,\n      image: image,\n      aspect: aspect,\n      shape: shape,\n      grid: grid,\n      zoom: zoom,\n      rotate: rotate,\n      rotateValRef: rotateValRef,\n      setZoomValRef: setZoomValRef,\n      setRotateValRef: setRotateValRef,\n      minZoom: minZoom,\n      maxZoom: maxZoom,\n      cropPixelsRef: cropPixelsRef,\n      cropperProps: cropperProps\n    })));\n  };\n\n  if (modalTitle) return getComponent(modalTitle);\n  return /*#__PURE__*/React.createElement(LocaleReceiver, null, function (locale, code) {\n    return getComponent(code === 'zh-cn' ? '编辑图片' : 'Edit image');\n  });\n});\nexport { ImgCrop as default };","map":null,"metadata":{},"sourceType":"module"}